// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: orders.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addItemToOrder = `-- name: AddItemToOrder :exec
INSERT INTO orders_menu_items (fk_order_id, fk_menu_item_id) VALUES ($1, $2)
`

type AddItemToOrderParams struct {
	FkOrderID    pgtype.UUID `json:"fk_order_id"`
	FkMenuItemID pgtype.UUID `json:"fk_menu_item_id"`
}

func (q *Queries) AddItemToOrder(ctx context.Context, arg AddItemToOrderParams) error {
	_, err := q.db.Exec(ctx, addItemToOrder, arg.FkOrderID, arg.FkMenuItemID)
	return err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (menu_id, customer_name) VALUES ($1, $2) RETURNING id, menu_id, customer_name, created_at, updated_at, status
`

type CreateOrderParams struct {
	MenuID       pgtype.UUID `json:"menu_id"`
	CustomerName string      `json:"customer_name"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder, arg.MenuID, arg.CustomerName)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.MenuID,
		&i.CustomerName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const deleteItemsFromOrder = `-- name: DeleteItemsFromOrder :exec
DELETE FROM orders_menu_items WHERE fk_order_id = $1
`

func (q *Queries) DeleteItemsFromOrder(ctx context.Context, fkOrderID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteItemsFromOrder, fkOrderID)
	return err
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM orders WHERE id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrder, id)
	return err
}

const findOrder = `-- name: FindOrder :many
SELECT id, menu_id, customer_name, created_at, updated_at, status FROM orders WHERE LOWER(customer_name) LIKE $1 ORDER BY created_at ASC
`

func (q *Queries) FindOrder(ctx context.Context, customerName string) ([]Order, error) {
	rows, err := q.db.Query(ctx, findOrder, customerName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.MenuID,
			&i.CustomerName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrder = `-- name: GetOrder :one
SELECT id, menu_id, customer_name, created_at, updated_at, status FROM orders WHERE id = $1
`

func (q *Queries) GetOrder(ctx context.Context, id pgtype.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, getOrder, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.MenuID,
		&i.CustomerName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const getOrderItems = `-- name: GetOrderItems :many
SELECT mi.name
FROM orders AS o
INNER JOIN orders_menu_items AS omi ON omi.fk_order_id = o.id
INNER JOIN menu_items AS mi ON mi.id = omi.fk_menu_item_id
WHERE o.id = $1
`

func (q *Queries) GetOrderItems(ctx context.Context, id pgtype.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getOrderItems, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrders = `-- name: GetOrders :many
SELECT id, menu_id, customer_name, created_at, updated_at, status FROM orders ORDER BY created_at ASC
`

func (q *Queries) GetOrders(ctx context.Context) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.MenuID,
			&i.CustomerName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByMenuID = `-- name: GetOrdersByMenuID :many
SELECT id, menu_id, customer_name, created_at, updated_at, status FROM orders WHERE menu_id = $1
`

func (q *Queries) GetOrdersByMenuID(ctx context.Context, menuID pgtype.UUID) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersByMenuID, menuID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.MenuID,
			&i.CustomerName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersItems = `-- name: GetOrdersItems :many
SELECT o.customer_name, o.id as order_id, mi.name as item_name, mi.id as item_id, o.status as order_status
FROM orders AS o
INNER JOIN orders_menu_items AS omi ON omi.fk_order_id = o.id
INNER JOIN menu_items AS mi ON mi.id = omi.fk_menu_item_id
ORDER BY o.created_at ASC
`

type GetOrdersItemsRow struct {
	CustomerName string      `json:"customer_name"`
	OrderID      pgtype.UUID `json:"order_id"`
	ItemName     string      `json:"item_name"`
	ItemID       pgtype.UUID `json:"item_id"`
	OrderStatus  string      `json:"order_status"`
}

func (q *Queries) GetOrdersItems(ctx context.Context) ([]GetOrdersItemsRow, error) {
	rows, err := q.db.Query(ctx, getOrdersItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrdersItemsRow
	for rows.Next() {
		var i GetOrdersItemsRow
		if err := rows.Scan(
			&i.CustomerName,
			&i.OrderID,
			&i.ItemName,
			&i.ItemID,
			&i.OrderStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE orders SET status = $2 WHERE id = $1 RETURNING id, menu_id, customer_name, created_at, updated_at, status
`

type UpdateOrderParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrder, arg.ID, arg.Status)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.MenuID,
		&i.CustomerName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}
